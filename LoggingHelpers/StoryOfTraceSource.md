 The Story of TraceSource

In the beginning, (2002, what is now known as .NET Full Framework 1.0), the new framework needed [logging, monitoring, and instrumentation](https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/tracing-and-instrumenting-applications) as part of it. This functionality was placed in the [System.Diagnostics](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics) namespace as both the [Trace](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.trace) object (always available, allowing production monitoring) and the [Debug](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debug) object (only compiled into a Debug configuration, preventing production slowdowns and delays).

As configuration was also built into the framework, it was easy (and recommended) to include [automatic configuration](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/trace-debug) through this system, though code-level configuration would be possible when necessary, and the [TraceSwitch](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.traceswitch) class was provided to allow sysadmins to control how much of the logging would occur without having to make code-level changes. 

The [TraceListener](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracelistener) class and its derived classes would be at the far end of this pipeline, providing output of the trace messages/events by [default to debuggers](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.defaulttracelistener), to the [console](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.consoletracelistener), to [text files](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.textwritertracelistener) ([in varying](https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualbasic.logging.filelogtracelistener) [fashions](http://www.nuget.org/packages/Essential.Diagnostics.RollingFileTraceListener)), to [XML files](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.xmlwritertracelistener), the [event logs](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.eventlogtracelistener), and eventually to [Event Tracing for Windows](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.eventing.eventprovidertracelistener). Others ([Essential.Diagnostics](https://github.com/sgryphon/essential-diagnostics) being the major currently maintained OSS set I'm aware of) have also written specific TraceListeners to pass the messages into other output forms and formats, such as databases or other logging frameworks. [TraceFilter](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracefilter)s could be [added to a TraceListener instance](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/trace-debug/filter-element) to reduce any flow of events unneeded by that particular listener/log.

As the .NET 2.0 timeframe rolled around, some additional features were required. Creating new trace pipelines was enabled by extending TraceSwitch into a [TraceSource](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracesource?view=netcore-1.0) object, each of which could have its own pipeline of TraceListeners and the ability to share those TraceListeners with each other and the original pipeline, so that the appropriate streams could be combined. Very few people found out about this extension, as there was no new namespace or assembly, or readable documentation for a long period.

.NET Core has actually ported almost all of the System.Diagnostics namespace; the one major missing portion as of Core 3.1 that I'm aware of is the formerly recommended configuration code. There were enough complaints about configuration presence and format that .NET Core has several optional configuration APIs instead of one common required API, and some have recommended that tuning of the monitoring be done in development anyway instead of allowing/forcing it to be done by the sysadmins. Even the new [Microsoft.Extensions.Logging namespace](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging?view=dotnet-plat-ext-1.0) (from the [.NET Platform Extensions](https://stackoverflow.com/questions/53097067/what-are-net-platform-extensions-on-docs-microsoft-com)) has its own [TraceSource extension namespace](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.tracesource?view=dotnet-plat-ext-1.0), connecting to this ubiquitious .NET monitoring functionality.

(Addendum: [OpenTelemetry](https://opentelemetry.io) has as its [SDK's entry point](https://opentelemetry.io/docs/instrumentation/net/) into the .NET Standard ecosystem... [System.Diagnostics](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics?view=net-7.0)!)

A better tutorial walking one through adding tracing is available at <https://github.com/sgryphon/essential-diagnostics/blob/develop/docs/Logging-Primer.md>
